<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SFARL的博客</title>
  
  <subtitle>守住底线-&gt;追求**</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="sfarl.github.io/"/>
  <updated>2020-07-13T11:51:37.192Z</updated>
  <id>sfarl.github.io/</id>
  
  <author>
    <name>SFARL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数学物理方程复习</title>
    <link href="sfarl.github.io/2020/07/04/%E5%81%8F%E5%BE%AE%E5%88%86%E5%A4%8D%E4%B9%A0/"/>
    <id>sfarl.github.io/2020/07/04/%E5%81%8F%E5%BE%AE%E5%88%86%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-07-04T09:36:28.000Z</published>
    <updated>2020-07-13T11:51:37.192Z</updated>
    
    <content type="html"><![CDATA[<p>目录</p><!-- GFM-TOC --><ul><li><a href="#基本概念">基本概念</a></li><li><a href="#二阶方程的特征理论和分类">二阶方程的特征理论和分类</a></li><li><!-- GFM-TOC --><a id="more"></a></li></ul><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="偏微分方程"><a href="#偏微分方程" class="headerlink" title="偏微分方程"></a>偏微分方程</h2><p>关于多元未知函数$u\left(x_{1}, \cdots, x_{n}\right)$及其偏导数的关系式：<br>$$F\left(x_{1}, \cdots, x_{n}, u, D u, D^{2} u, \cdots, D^{m} u\right)=0$$</p><ol><li>偏微分方程的阶数：未知函数偏导数最高阶数。</li><li>线性偏微分方程：未知函数和未知函数的各阶偏导都是线性的。<br>$$\sum_{|\alpha| \leq m} c_{\alpha}(x) D^{\alpha} u=f(x)$$ <ul><li>其中$c_{\alpha}(x)(|\alpha| \leq m)$和$f \left ( x \right )$都是不依赖于$u$和它的各阶偏导。</li><li>自由项：线性偏微分方程中不含$u$及其偏导数的项。</li><li>齐次方程：自由项为0</li></ul></li><li>非线性偏微分方程<ul><li>拟线性偏微分方程：在非线性偏微分方程中，关于未知函数的所有最高阶偏导数都是线性的。<br>$$\sum_{|\alpha|=m} c_{\alpha}\left(D^{m-1} u, \cdots, D u, u, x\right) D^{\alpha} u+c\left(D^{m-1} u, \cdots, D u, u, x\right)=0$$</li><li>主部：在拟线性偏微分方程中，由最高阶偏导数组成的部分。</li><li>半线性：主部的系数都是常数或是自变量的已知函数.<br>$$\sum_{|\alpha|=m} c_{\alpha}(x) D^{\alpha} u+c\left(D^{m-1} u, \cdots, D u, u, x\right)=0$$</li></ul></li></ol><h2 id="经典方程"><a href="#经典方程" class="headerlink" title="经典方程"></a>经典方程</h2><p>我们这门课程主要讲的就是三类基本方程。</p><ol><li>弦振动方程。</li><li>热传导方程。</li><li>Laplace方程。</li></ol><h2 id="定解问题"><a href="#定解问题" class="headerlink" title="定解问题"></a>定解问题</h2><ol><li>泛定方程：描绘普通规律的方程称为泛定方程。</li><li>定解条件：初始条件（Cauchy问题）和边界条件</li><li>三类典型边界条件：<ul><li>第一边界问题（Dirichlet问题）<br>$$\left.u\right|_{\Gamma}=\varphi(x, y, z, t)$$</li><li>第二边界问题（Neumann问题）<br>$$\left.\frac{\partial u}{\partial v}\right|_{\Gamma}=\varphi(x, y, z, t)$$</li><li>第三边界问题（Robin问题）<br>$$\left.\left(\frac{\partial u}{\partial v}+\sigma u\right)\right|_{\Gamma}=\varphi(x, y, z, t)$$</li></ul></li><li>适定性：满足下面三个条件的定解问题，称为适定的。<ul><li>存在性：至少存在一个解</li><li>唯一性：至多存在一个解</li><li>稳定性：定解条件微小变动的情况下，解也只做微小变动。</li></ul></li></ol><h1 id="二阶方程的特征理论和分类"><a href="#二阶方程的特征理论和分类" class="headerlink" title="二阶方程的特征理论和分类"></a>二阶方程的特征理论和分类</h1><h2 id="二阶方程的特征"><a href="#二阶方程的特征" class="headerlink" title="二阶方程的特征"></a>二阶方程的特征</h2><p>考虑一般的二阶线性方程：<br>$$\sum_{i, j=1}^{n} a_{i j} \frac{\partial^{2} u}{\partial x_{i} \partial x_{j}}+\sum_{i=1}^{n} b_{i} \frac{\partial u}{\partial x_{i}}+c u=f$$<br>其中$a_{ij}$, $b_i$, $c$, $f$ 为$x_{1}, \cdots, x_{n}$的已知函数，且在$R^n$内连续可微，$a_{ij} = a_{ji}$.</p><h3 id="特征曲面和特征方程"><a href="#特征曲面和特征方程" class="headerlink" title="特征曲面和特征方程"></a>特征曲面和特征方程</h3><p>假设$S$是R^n空间的一个曲面。<br>$$S: G\left(x_{1}, x_{2}, \cdots, x_{n}\right)=0$$<br>若：<br>$$\sum_{i, j=1}^{n} a_{i j} \frac{\partial G}{\partial x_{i}} \frac{\partial G}{\partial x_{j}}=0$$<br>称$S$为特征曲面。</p><p>称：<br>$$\sum_{i, j=1}^{n} a_{i j} \alpha_{i} \alpha_{j}=0$$<br>为偏微分方程的特征方程。</p><p>特征方程在点$P\left(x_{1}^{0}, \cdots, x_{n}^{0}\right)$处的解$l\left(\alpha_{1}, \cdots, \alpha_{n}\right)$为偏微分方程在点$P$处的特征方向。</p><h3 id="两个自变量的情形"><a href="#两个自变量的情形" class="headerlink" title="两个自变量的情形"></a>两个自变量的情形</h3><p>两个自变量的二阶拟线性偏微分方程的一般形式<br>$$a u_{x x}+2 b u_{x y}+c u_{y y}=F$$<br>假设$\Gamma$是平面$xoy$上的一条曲线。<br>当$\Gamma: x=\varphi(t), \quad y=\psi(t)$时，若<br>$$\Delta=a \psi^{\prime 2}-2 b \varphi^{\prime} \psi^{\prime}+c \varphi^{\prime 2} = 0$$</p><ul><li>$b$前面为什么是负号：看笔记，是根据一个三元$(U_{xx}, U_{xy}, U_{yy})$线性方程组行列式为0得出的特征方程。</li></ul><p>称$\Gamma$为特征曲线。<br>$$a \mathrm{d} y^{2}-2 b \mathrm{d} x \mathrm{d} y+c \mathrm{d} x^{2}=0$$<br>为偏微分方程的特征方程。</p><p>当$\Gamma: y=\psi(x)$时$(a \neq 0)$，有<br>$$\frac{\mathrm{d} y}{\mathrm{d} x}=\frac{b \pm \sqrt{b^{2}-a c}}{a}$$</p><p>当$\Gamma: \varphi(x, y)=0$时，特征方程为<br>$$a \varphi_{x}^{2}+2 b \varphi_{x} \varphi_{y}+c \varphi_{y}^{2}=0$$<br>这是因为<br>$$\varphi_{x} dx + \varphi_{y} dy=0$$<br>对$\Gamma: \varphi(x, y)=0$两边微分的结果。这与多个自变量的情形的定义是一致的。</p><h2 id="二阶方程的分类"><a href="#二阶方程的分类" class="headerlink" title="二阶方程的分类"></a>二阶方程的分类</h2><h3 id="两个自变量的情形-1"><a href="#两个自变量的情形-1" class="headerlink" title="两个自变量的情形"></a>两个自变量的情形</h3><p>考虑以下线性偏微分方程<br>$$a u_{x x}+2 b u_{x y}+c u_{y y}+d u_{x}+e u_{y}+g u=f$$<br>其中$a, b, c, d, e, g, f 是x,y$的已知函数。</p><p>做变量变换<br>$$\left{\begin{array}{l}<br>\xi=\varphi(x, y) \<br>\eta=\psi(x, y)<br>\end{array}\right.$$<br>方程可转换为<br>$$A \frac{\partial^{2} u}{\partial \xi^{2}}+2 B \frac{\partial^{2} u}{\partial \xi \partial \eta}+C \frac{\partial^{2} u}{\partial \eta^{2}}+D \frac{\partial u}{\partial \xi}+E \frac{\partial u}{\partial \eta}+G u=F$$<br>二阶偏导<br>$$\begin{array}{c}<br>\frac{\partial^{2} u}{\partial x^{2}}=\frac{\partial^{2} u}{\partial \xi^{2}}\left(\frac{\partial \xi}{\partial x}\right)^{2}+2 \frac{\partial^{2} u}{\partial x} \frac{\partial \eta}{\partial x}+\frac{\partial^{2} u}{\partial n^{2}}\left(\frac{\partial \eta}{\partial x}\right)^{2}+\frac{\partial^{2} \xi}{\partial x^{2}}+\frac{\partial^{2} \eta}{\partial x^{2}} \<br>\frac{\partial^{2} u}{\partial x \partial y}=\frac{\partial^{2}}{\partial \varepsilon^{2}} \frac{\partial \xi}{\partial x} \frac{\partial \xi}{\partial y}+\frac{\partial^{2} u}{\partial \xi \partial n}\left(\frac{\partial \xi}{\partial x} \frac{\partial \eta}{\partial y}+\frac{\partial \xi}{\partial y} \frac{\partial \eta}{\partial x}\right)+\frac{\partial^{2}}{\partial x^{2}} \frac{\partial \eta}{\partial x} \frac{\partial \eta}{\partial y}+\frac{\partial u}{\partial x \partial y}+\frac{\partial^{2} \xi}{\partial x \partial y} \<br>\frac{\partial^{2} u}{\partial y^{2}}=\frac{\partial^{2} u}{\partial \xi^{2}}\left(\frac{\partial \xi}{\partial y}\right)^{2}+2 \frac{\partial^{2} \eta}{\partial \xi(\eta)} \frac{\partial \xi}{\partial y} \frac{\partial \eta}{\partial y}+\frac{\partial^{2} u}{\partial n^{2}}\left(\frac{\partial \eta}{\partial y}\right)^{2}+\frac{\partial^{2} \xi}{\partial y^{2}}+\frac{\partial^{2} \eta}{\partial y^{2}}<br>\end{array}$$<br>带入可得<br>$$\left{\begin{array}{l}<br>A(\xi, \eta)=a \varphi_{x}^{2}+2 b \varphi_{x} \varphi_{y}+c \varphi_{y}^{2} \<br>B(\xi, \eta)=a \varphi_{x} \psi_{x}+b\left(\varphi_{x} \psi_{y}+\varphi_{y} \psi_{x}\right)+c \varphi_{y} \psi_{y} \<br>C(\xi, \eta)=a \psi_{x}^{2}+2 b \psi_{x} \psi_{y}+c \psi_{y}^{2} \<br>D(\xi, \eta)=a \varphi_{x x}+2 b \varphi_{x y}+c \varphi_{y y}+d \varphi_{x}+e \varphi_{y} \<br>E(\xi, \eta)=a \psi_{x x}+2 b \psi_{x y}+c \psi_{y y}+d \psi_{x}+e \psi_{y} \<br>G(\xi, \eta)=g(x, y) \<br>F(\xi, \eta)=f(x, y)<br>\end{array}\right.$$<br>最后的A到G还需要通过变换<br>$$\left{\begin{array}{l}<br>\xi=\varphi(x, y) \<br>\eta=\psi(x, y)<br>\end{array}\right.$$<br>将$(x,y)$成$(\xi, \eta)。$</p><p>一个记忆法，把A-E写成矩阵形式。（笔记）</p><p>方程判别式<br>$$\Delta=b^{2}-a c$$<br>$$\Delta^{\prime}=B^{2}-A C$$<br>他们之间有着如下的关系<br>$$\Delta^{\prime}=J^{2} \Delta$$<br>$$J=\left|\begin{array}{ll}<br>\varphi_{x} &amp; \varphi_{y} \<br>\psi_{x} &amp; \psi_{y}<br>\end{array}\right|$$</p><p>在$J \neq 0$的情况下，$\Delta = \Delta^{\prime}$，所以这是可逆自变换下的不变性。通过这个来分类。<br>$$\begin{array}{l}<br>\Delta&gt;0 双曲型偏微分方程\<br>\Delta=0 抛物型偏微分方程\<br>\Delta&lt;0 椭圆形偏微分方程<br>\end{array}$$</p><h3 id="方程标准型"><a href="#方程标准型" class="headerlink" title="方程标准型"></a>方程标准型</h3><p><strong>考虑两个自变量常系数的情形</strong>：<br>$$a u_{x x}+2 b u_{x y}+c u_{y y}+d u_{x}+e u_{y}+g u=f(x, y)$$<br>其中$a, b, c, d,e,g$都是常数。</p><h4 id="情形1：-双曲型方程的标准型-Delta-gt-0"><a href="#情形1：-双曲型方程的标准型-Delta-gt-0" class="headerlink" title="情形1： 双曲型方程的标准型 $\Delta &gt; 0$"></a>情形1： 双曲型方程的标准型 $\Delta &gt; 0$</h4><p>两族实特征线为：<br>$$\left{\begin{array}{l}<br>y-\frac{b+\sqrt{\Delta}}{a} x=c_{1} \<br>y-\frac{b-\sqrt{\Delta}}{a} x=c_{2}<br>\end{array}\right.$$<br>做变换<br>$$ \left{\begin{array}{l}<br>\xi =y-\frac{b+\sqrt{\Delta}}{a}  \<br>\eta = y-\frac{b-\sqrt{\Delta}}{a} x<br>\end{array}\right.$$<br>方程化为双曲型方程的第一标准型(只含混合导数)<br>$$ u_{\xi \eta} = Du_{\xi} + Eu_\eta +Gu+F(\xi, \eta)$$<br>引入变换<br>$$\bar{x}=\xi+\eta, \quad \bar{y}=\xi-\eta$$<br>方程可化为双曲型方程的第二标准型(不含混合导数)<br>$$u_{\bar{x}\bar{x}}-u_{\bar{y} \bar{y}}=D_{1} u_{\bar{x}}+E_{1} u_{\bar{y}}+G_{1} u+F_{1}(\bar{x}, \bar{y})$$</p><h4 id="情形2：-抛物型方程的标准型-Delta-0"><a href="#情形2：-抛物型方程的标准型-Delta-0" class="headerlink" title="情形2： 抛物型方程的标准型 $\Delta = 0$"></a>情形2： 抛物型方程的标准型 $\Delta = 0$</h4><p>只有一族实特征线：<br>$$ y - \frac{b}{a}x = c$$<br>引入变换<br>$$ \xi = y- \frac{b}{a}x, \eta = y$$<br>方程化为抛物型方程的标准型(只剩下$\eta$的二阶偏导)<br>$$ u_{\eta \eta} = Du_{\xi} + Eu_\eta +Gu+F(\xi, \eta)$$</p><h4 id="情形3：-抛物型方程的标准型-Delta-gt-0"><a href="#情形3：-抛物型方程的标准型-Delta-gt-0" class="headerlink" title="情形3： 抛物型方程的标准型 $\Delta &gt; 0$"></a>情形3： 抛物型方程的标准型 $\Delta &gt; 0$</h4><p>做变换：<br>$$ \left{\begin{array}{l}<br>\xi =y-\frac{b+i\sqrt{\Delta}}{a}  \<br>\eta = y-\frac{b-i\sqrt{\Delta}}{a} x<br>\end{array}\right.$$<br>再作变换抽取出实部和虚部<br>$$\left{\begin{array}{l}\bar{\xi}=\frac{1}{2}(\xi+\eta)=y-\frac{b}{a} x \ \bar{\eta}=\frac{1}{2 i}(\xi-\eta)=-\frac{\sqrt{a c-b^{2}}}{a} x\end{array}\right.$$<br>方程化为椭圆型方程的标准型<br>$$ u_{\bar\eta \bar\eta} + u_{\bar\xi \bar\xi} = Du_{\xi} + Eu_\eta +Gu+F(\bar\xi, \bar\eta)$$</p><h4 id="变系数"><a href="#变系数" class="headerlink" title="变系数"></a>变系数</h4><p>变系数需要根据系数判断$\Delta$的正负（有可能区域不同有不同类型的标准型），对特征方程进行积分，再做适当的特征变换。</p><h3 id="多变量的分类与标准型"><a href="#多变量的分类与标准型" class="headerlink" title="多变量的分类与标准型"></a>多变量的分类与标准型</h3><p>只考虑主部为常系数的情形<br>$$\sum_{i, j=1}^{n} a_{i j} \frac{\partial^{2} u}{\partial x_{i} \partial x_{j}}+\sum_{i=1}^{n} b_{i}\left(x_{1}, \cdots, x_{n}\right) \frac{\partial u}{\partial x_{i}}+c\left(x_{1}, \cdots, x_{n}\right) u=f\left(x_{1}, \cdots, x_{n}\right)$$<br>其中$a_{ij} = a_{ji}$，上式的特征方程为<br>$$\sum_{i, j=1}^{n} a_{i j} \alpha_{i} \alpha_{j}=0$$<br>记$D = \sum_{i, j=1}^{n} a_{i j} \alpha_{i} \alpha_{j}$为方程的特征二次型。<br>存在可逆线性变换<br>$$\left(\begin{array}{c}\alpha_{1} \ \alpha_{2} \ \vdots \ \alpha_{n}\end{array}\right)=B\left(\begin{array}{c}\beta_{1} \ \beta_{2} \ \vdots \ \beta_{n}\end{array}\right)$$<br>使得特征二次型化为标准型<br>$$D = \sum_{i, j=1}^{n} \lambda_{i} \beta_{i}^2$$<br>其中$\lambda_i = 0, -1, 或1$.<br>对自变量做变换<br>$$\left(\begin{array}{c}y_{1} \ y_{2} \ \vdots \ y_{n}\end{array}\right)=B^{T}\left(\begin{array}{c}x_{1} \ x_{2} \ \vdots \ x_{n}\end{array}\right)$$<br>就可以将偏微分方程化为<br>$$\sum_{i=1}^{n} \lambda_{i} \frac{\partial^{2} u}{\partial y_{i}^{2}}+\sum_{i=1}^{n} B_{i}\left(y_{1}, \cdots, y_{n}\right) \frac{\partial u}{\partial y_{i}}+C\left(y_{1}, \cdots, y_{n}\right) u=F\left(y_{1}, \cdots, y_{n}\right)$$</p><h4 id="多变量分类"><a href="#多变量分类" class="headerlink" title="多变量分类"></a>多变量分类</h4><ol><li>$\lambda_i$全是1，椭圆型方程。</li><li>其中一个是1，其余负1.或者其中一个负1，其余都是1.双曲型。</li><li>一个是0，其余全是1或全是负1.抛物型。</li></ol><h1 id="分离变量法"><a href="#分离变量法" class="headerlink" title="分离变量法"></a>分离变量法</h1><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>分离变量法的解题步骤可分为三步。</p><ol><li>第一步：令$u(x,t) - X(x)T(t)$代入方程和边界条件。从而定出$X(x)$所适合的Sturm-Lioubille 问题及$T(t)$适合的常微分方程。</li><li>第二步：解Sturm-Liouville问题，求出全部特征值和特征函数, 并求出相应的$T(t)$的表达式. </li><li>第三步：将所有变量分离形式的特解叠加起来，并利用初始条件定出所有待定常数</li></ol><p>具体操作通过具体案例来体现。看笔记。</p><h2 id="求解实例"><a href="#求解实例" class="headerlink" title="求解实例"></a>求解实例</h2><p>课本P40</p><h1 id="双曲型方程"><a href="#双曲型方程" class="headerlink" title="双曲型方程"></a>双曲型方程</h1><h2 id="Duhamel原理"><a href="#Duhamel原理" class="headerlink" title="Duhamel原理"></a>Duhamel原理</h2><p>非常有用的一个原理，将非齐次方程定解问题的求解转为齐次方程定解问题的求解。除了双曲型方程，抛物型方程也适用。</p><p>考虑在$\mathbb{R}^{n} \times[0, \infty)$上的$n$维波动方程。</p><p>$$\left{\begin{array}{ll}\square u=\frac{\partial^{2} u}{\partial t^{2}}-a^{2} \Delta u=f\left(x_{1}, \cdots, x_{n}, t\right), &amp; \left(x_{1}, \cdots, x_{n}, t\right) \in \mathbb{R}^{n} \times(0, \infty) \ u\left(x_{1}, \cdots, x_{n}, 0\right)=\varphi\left(x_{1}, \cdots, x_{n}\right), &amp; \left(x_{1}, \cdots, x_{n}\right) \in \mathbb{R}^{n} \ u_{t}\left(x_{1}, \cdots, x_{n}, 0\right)=\psi\left(x_{1}, \cdots, x_{n}\right), &amp; \left(x_{1}, \cdots, x_{n}\right) \in \mathbb{R}^{n}\end{array}\right.$$<br><strong>因为方程是线性的</strong><br>可以将方程拆成下述三个定解问题。<br>$$(\mathrm{I})\left{\begin{array}{l}\square u_{1}=0 \ u_{1}\left(x_{1}, \cdots, x_{n}, 0\right)=\varphi\left(x_{1}, \cdots, x_{n}\right) \ u_{1 t}\left(x_{1}, \cdots, x_{n}, 0\right)=0\end{array}\right.$$</p><p>$$(\mathrm{II})\left{\begin{array}{l}\square u_{1}=0 \ u_{1}\left(x_{1}, \cdots, x_{n}, 0\right)=0 \ u_{1 t}\left(x_{1}, \cdots, x_{n}, 0\right)=\psi\left(x_{1}, \cdots, x_{n}\right)\end{array}\right.$$</p><p>$$(\mathrm{III})\left{\begin{array}{l}\square u_{1}=f\left(x_{1}, \cdots, x_{n}, t\right) \ u_{1}\left(x_{1}, \cdots, x_{n}, 0\right)=0 \ u_{1 t}\left(x_{1}, \cdots, x_{n}, 0\right)=0\end{array}\right.$$</p><p>接下来，首先要的解的是问题$\mathrm{II}$。(分离变量还有其他吗？)</p><p>设$u_2 = U_{\psi}\left(x_{1}, \cdots, x_{n}, t\right)$是$\mathrm{II}$的解，则$\mathrm{I}$，$\mathrm{III}$的解$u_1, u_3$可分别表示为：</p><p>$$u_{1}\left(x_{1}, \cdots, x_{n}, t\right)=\frac{\partial}{\partial t} U_{\varphi}\left(x_{1}, \cdots, x_{n}, t\right)$$</p><p>$$u_{3}\left(x_{1}, \cdots, x_{n}, t\right)=\int_{0}^{t} U_{f_{\tau}}\left(x_{1}, \cdots, x_{n}, t-\tau\right) \mathrm{d} \tau$$</p><p>这里的$U_{\psi}，U_{\varphi}，U_{f_{\tau}}$表示当$\mathrm{II}$里的$U_{\psi}$用$U_{\varphi}$或者$U_{f_{\tau}}$换掉后的解。</p><h3 id="混合问题"><a href="#混合问题" class="headerlink" title="混合问题"></a>混合问题</h3><ol><li>边界条件齐次化。通过线性函数将边界条件化为0.<br>$$U(x, t)=\mu_{1}(t)+\frac{x}{l}\left(\mu_{2}(t)-\mu_{1}(t)\right)$$<br>$$U(x, t)=x\mu_{1}(t)+\frac{x^2}{2l}\left(\mu_{2}(t)-\mu_{1}(t)\right)$$</li></ol><h2 id="一维波动方程"><a href="#一维波动方程" class="headerlink" title="一维波动方程"></a>一维波动方程</h2><h3 id="齐次波动方程的Cauchy问题和特征线法。"><a href="#齐次波动方程的Cauchy问题和特征线法。" class="headerlink" title="齐次波动方程的Cauchy问题和特征线法。"></a>齐次波动方程的Cauchy问题和特征线法。</h3><p>定解问题如下<br>$$u_{t t}-a^{2} u_{x x}=0, \quad-\infty&lt;x&lt;\infty, \quad t&gt;0$$<br>$$u(x, 0)=\varphi(x), \quad u_{t}(x, 0)=\psi(x), \quad-\infty&lt;x&lt;\infty$$<br>特征线解法见笔记。</p><h3 id="D’Alembert公式"><a href="#D’Alembert公式" class="headerlink" title="D’Alembert公式"></a>D’Alembert公式</h3><p>通过对齐次波动方程的Cauchy问题用特征线法导出的D’Alembert公式<br>$$u(x, t)=\frac{1}{2}[\varphi(x-a t)+\varphi(x+a t)]+\frac{1}{2 a} \int_{x-a t}^{x+a t} \psi(\tau) \mathrm{d} \tau$$<br>D’Alembert公式不仅给出了弦振动方程柯西问题解的表达式, 还可用于求解四分之一平面上的问题以及导出弦振动方程的一些重要性质.</p><h3 id="依赖区域、决定区域和影响区域"><a href="#依赖区域、决定区域和影响区域" class="headerlink" title="依赖区域、决定区域和影响区域"></a>依赖区域、决定区域和影响区域</h3><ul><li>依赖区域：<br><img src="https://s1.ax1x.com/2020/07/11/Ul0q1A.png" alt="依赖区域"><br>依赖区域是指上述的解$u(x,t)$在点$(x,t)$依赖于数值依赖于这一片区域。<br>$$[x-at, x+at]$$</li><li>决定区域：<br><img src="https://s1.ax1x.com/2020/07/11/UlBVBV.png" alt="决定区域"><br>决定区域是指给定$[x_1, x_2]$，能决定$xOt$上那些点的函数值。<br>$$D: {(x,t) |x_1 + at \leq x \leq x_2 - at,\ \ t&gt;0}$$</li><li>影响区域<br><img src="https://s1.ax1x.com/2020/07/11/UlBuh4.png" alt="影响区域"><br>影响区域是指给定$[x_1, x_2]$，会影响到$xOt$上那些点的函数值。<br>$$G: {(x,t) |x_1 - at \leq x \leq x_2 + at,\ \ t&gt;0}$$</li></ul><h2 id="高维波动方程"><a href="#高维波动方程" class="headerlink" title="高维波动方程"></a>高维波动方程</h2><p>考虑三维齐次波动方程的Cauchy问题，<br>$$\left{\begin{array}{l}u_{t t}-a^{2}\left(u_{x x}+u_{y y}+u_{z z}\right)=0,-\infty&lt;x, y, z&lt;\infty, t&gt;0 \ \left.u\right|<em>{t=0}=\varphi(x, y, z),\left.u</em>{t}\right|<em>{t=0}=\psi(x, y, z),-\infty&lt;x, y, z&lt;\infty\end{array}\right.$$<br>根据一维D’Alembert猜测高维的D’Alembert公式也具有下述形式的解。称为Poisson公式。<br>$$u(x, y, z, t)=\frac{\partial}{\partial t}\left(t v</em>{\varphi}(x, y, z, t)\right)+t v_{\psi}(x, y, z, t)$$<br>其中<br>$$\left{\begin{array}{l}v_{\varphi}(x, y, z, t)=\frac{1}{4 \pi a^{2} t^{2}} \iint_{S_{a t}(M)} \varphi \mathrm{d} S \ v_{\psi}(x, y, z, t)=\frac{1}{4 \pi a^{2} t^{2}} \iint_{S_{a t}(M)} \psi \mathrm{d} S\end{array}\right.$$<br>$\frac{1}{4 \pi a^{2} t^{2}}$是$at$为半径的球面上的平均值。</p><p>对于偶数维的，采用降维法，补充一个变量变成高一维的奇数维求解。</p><h3 id="高维依赖区域"><a href="#高维依赖区域" class="headerlink" title="高维依赖区域"></a>高维依赖区域</h3><p>变成了圆锥。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://s1.ax1x.com/2020/07/12/U1OWyd.png" alt="小结1"><br><img src="https://s1.ax1x.com/2020/07/12/U1XVmR.png" alt="小结2"><br><img src="https://s1.ax1x.com/2020/07/12/U1XbAx.png" alt="小结3"></p><h1 id="抛物型方程"><a href="#抛物型方程" class="headerlink" title="抛物型方程"></a>抛物型方程</h1><h2 id="热传导方程定解问题的求解"><a href="#热传导方程定解问题的求解" class="headerlink" title="热传导方程定解问题的求解"></a>热传导方程定解问题的求解</h2><h3 id="齐次热方程的Cauchy问题"><a href="#齐次热方程的Cauchy问题" class="headerlink" title="齐次热方程的Cauchy问题"></a>齐次热方程的Cauchy问题</h3><p>方程如下：<br>$$\left{\begin{array}{ll}u_{t}-a^{2} u_{x x}=0, &amp; -\infty&lt;x&lt;\infty, t&gt;0 \ \left.u\right|<em>{t=0}=\varphi(x), &amp; -\infty&lt;x&lt;\infty\end{array}\right.$$<br><strong>要背</strong>：解的表达式——Poisson公式：<br>$$u(x, t)=\int</em>{-\infty}^{\infty} G(x-y, t) \varphi(y) \mathrm{d} y$$<br>其中热核函数：<br>$$G(x, t)=\left{\begin{array}{ll}\frac{1}{2 a \sqrt{\pi t}} \mathrm{e}^{-\frac{x^{2}}{4 a^{2} t}}, &amp; t&gt;0 \ 0, &amp; t&lt;0\end{array}\right.$$</p><h3 id="非齐次热方程的Cauchy问题"><a href="#非齐次热方程的Cauchy问题" class="headerlink" title="非齐次热方程的Cauchy问题"></a>非齐次热方程的Cauchy问题</h3><p>方程如下：<br>$$\left{\begin{array}{ll}u_{t}-a^{2} u_{x x}=f(x,t), &amp; -\infty&lt;x&lt;\infty, t&gt;0 \ \left.u\right|<em>{t=0}=\varphi(x), &amp; -\infty&lt;x&lt;\infty\end{array}\right.$$<br><strong>要背</strong>：解的表达式：<br>$$u(x, t)=\int</em>{-\infty}^{\infty} G(x-y, t) \varphi(y) \mathrm{d} y+\int_{0}^{t} \int_{-\infty}^{\infty} G(x-y, t-\tau) f(y, \tau) \mathrm{d} y \mathrm{d} \tau$$<br>其中热核函数：<br>$$G(x, t)=\left{\begin{array}{ll}\frac{1}{2 a \sqrt{\pi t}} \mathrm{e}^{-\frac{x^{2}}{4 a^{2} t}}, &amp; t&gt;0 \ 0, &amp; t&lt;0\end{array}\right.$$</p><h3 id="半直线上的混合问题"><a href="#半直线上的混合问题" class="headerlink" title="半直线上的混合问题"></a>半直线上的混合问题</h3><p>$$\left{\begin{array}{ll}u_{t}-a^{2} u_{x x}=f(x, t), &amp; 0&lt;x&lt;\infty, t&gt;0 \ u(x, 0)=\varphi(x), &amp; 0 \leq x&lt;\infty \ u(0, t)=\mu(t), &amp; t \geq 0\end{array}\right.$$<br>先将边界条件齐次化：$v(x,t) = u(x,t) - \mu (x,t)$<br>就有：<br>$$\left{\begin{array}{l}v_{t}-a^{2} v_{x x}=f(x, t)-\mu^{\prime}(t) \ \left.v\right|<em>{t=0}=\varphi(x)-\mu(0) \ \left.v\right|</em>{x=0}=0\end{array}\right.$$<br>在由叠加原理，分成两个问题。结合奇延拓法求解。</p><h3 id="热核函数常见变换"><a href="#热核函数常见变换" class="headerlink" title="热核函数常见变换"></a>热核函数常见变换</h3><ol><li><p>$\mathrm{e}^{-\frac{(x-y)^{2}}{4 a^{2} t}}$，做$z=\frac{x-y}{2a \sqrt t}$</p><p>  就会变成：<br>  $$\begin{aligned} I_{1} &amp;=\frac{1}{2 a \sqrt{\pi t}} \int_{-\infty}^{0} A \mathrm{e}^{-\frac{(x-y)^{2}}{4 a^{2} t}} \mathrm{d} y \ &amp;=-\frac{A}{\sqrt{\pi}} \int_{+\infty}^{\frac{x}{2 a \sqrt{t}}} \mathrm{e}^{-z^{2}} \mathrm{d} z \end{aligned}$$<br>  最后，记：<br>  $$\operatorname{erf}(s)=\frac{2}{\sqrt{\pi}} \int_{0}^{s} \mathrm{e}^{-z^{2}} \mathrm{d} z, \quad \operatorname{erf}(s)=1-\operatorname{erf}(s)$$</p></li><li><p>$$\frac{1}{\sqrt \pi}\int_{-\infty}^{\infty}e^{-x^2}dx = 1$$</p></li><li><p>$$\int_{0}^{+\infty} e^{-x^{2}} \cos r x d x=\frac{\sqrt{\pi}}{2} e^{-\frac{r^{2}}{4}}$$</p></li></ol><h2 id="极值原理"><a href="#极值原理" class="headerlink" title="极值原理"></a>极值原理</h2><h3 id="弱极值原理"><a href="#弱极值原理" class="headerlink" title="弱极值原理"></a>弱极值原理</h3><p>$f(x,t)\leq0$且$u \in C^{2,\ 1}(Q_T) \cap C(\bar{Q_T})$的解则$u(x,t)$的最大值必定在$Q_T$的抛物边界$\Gamma_T$上达到.<br><img src="https://s1.ax1x.com/2020/07/12/U30eSJ.png" alt="弱极值"><br>证明用反证法。<br>构造：<br>$$v(x, t)=u(x, t)+\frac{M-m}{4 n d^{2}}\left|x-x^{*}\right|^{2}, \quad$$<br>其中<br>$$d=\max {|x-y| \mid x, y \in \bar{\Omega}}$$<br>然后用强极值原理</p><h3 id="一般情况下的弱极值原理"><a href="#一般情况下的弱极值原理" class="headerlink" title="一般情况下的弱极值原理"></a>一般情况下的弱极值原理</h3><p>$$L u=u_{t}-a^{2} \Delta u+\sum_{i}^{n} b_{i}(x, t) u_{x_{i}}+c(x, t) u=f(x, t)$$<br>设$c(x,t) \geq 0, f(x,t)\leq0$，$u \in C^{2,\ 1}(Q_T) \cap C(\bar{Q_T})$</p><p>则$u(x,t)$在$\bar Q$上非负最大值(如果存在的话) 必在$\Gamma$上达到。</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>上述若$c(x,t)\geq -c_0$，如果 $\max <em>{\Gamma</em>{T}} u(x, t) \leqslant 0,$ 那么必有 $\max <em>{\bar{Q}</em>{T}} u(x, t) \leqslant 0$</p><p>反证法：令$v(x,t) = e^{-c_0t}u(x,t)$</p><h3 id="比较原理"><a href="#比较原理" class="headerlink" title="比较原理"></a>比较原理</h3><p>$$\mathcal{L} u=u_{t}-a^{2} \Delta u+\sum_{i}^{n} b_{i}(x, t) u_{x_{i}}+c(x, t) u=f(x, t)$$<br>$c(x,t)\geq -c_0$且$u,\ v \in C^{2,\ 1}(Q_T) \cap C(\bar{Q_T})$的解，$\mathcal{L} u \leqslant \mathcal{L} v$，$\left.u\right|<em>{\Gamma</em>{T}} \leqslant\left. v\right|<em>{\Gamma</em>{T}},$ 则在 $\bar{Q}_{T}$ 上: $u(x, t) \leqslant v(x, t)$</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><img src="https://s1.ax1x.com/2020/07/12/U3DvWD.png" alt=""><br><img src="https://s1.ax1x.com/2020/07/12/U3rPeI.png" alt=""><br><img src="https://s1.ax1x.com/2020/07/12/U3rEY8.png" alt=""><br><img src="https://s1.ax1x.com/2020/07/12/U3rVfS.png" alt=""><br><img src="https://s1.ax1x.com/2020/07/12/U3rMmn.png" alt=""><br>这个是个特殊些的例子<br><img src="https://s1.ax1x.com/2020/07/12/U3rN6J.png" alt=""><br>先做齐次变换，再构造$W = Ft+B$，其中<br>$F = max_{\bar Q_T}|f_t(x,t)|$，$B = $max|\phi(x)|$<br>最后用比较原理。</p><p>另一个比较特殊的应用例子<br><img src="https://s1.ax1x.com/2020/07/12/U83rdJ.png" alt=""><br><img src="https://s1.ax1x.com/2020/07/12/U88uk9.png" alt=""><br>凸函数，存在$\alpha$，使得<br>$$ f(u_x) \geq f(v_x) + \alpha (u_x - v_x)$$</p><p>还有这种，需要先求导<br><img src="https://s1.ax1x.com/2020/07/12/U8GfVe.png" alt=""><br>再通过函数变换, 归结为极值原理的应用.</p><h2 id="两类方程的对比"><a href="#两类方程的对比" class="headerlink" title="两类方程的对比"></a>两类方程的对比</h2><h3 id="波动方程"><a href="#波动方程" class="headerlink" title="波动方程"></a>波动方程</h3><p>$$\left{\begin{array}{l}u_{t t}-a^{2} u_{x x}=f(x, t), \quad x \in \mathbb{R}^{1}, t&gt;0 \ \left.u\right|<em>{t=0}=\varphi(x),\left.u</em>{t}\right|<em>{t=0}=\psi(x), \quad x \in \mathbb{R}^{1}\end{array}\right.$$<br>解的表达式<br>$$\begin{aligned} u(x, t)=&amp; \frac{1}{2}[\varphi(x-a t)+\varphi(x+a t)]+\frac{1}{2 a} \int</em>{x-a t}^{x+a t} \psi(\tau) \mathrm{d} \tau \ &amp;+\frac{1}{2 a} \int_{0}^{t} \int_{x-a(t-t)}^{x+a(t-t)} f(\xi, \tau) \mathrm{d} \xi \mathrm{d} \tau \end{aligned}$$</p><h3 id="热方程"><a href="#热方程" class="headerlink" title="热方程"></a>热方程</h3><p>$$\left{\begin{array}{l}u_{t}-a^{2} u_{x x}=f(x, t), \quad x \in \mathbb{R}^{1}, t&gt;0 \ \left.u\right|<em>{t=0}=\varphi(x), \quad x \in \mathbb{R}^{1}\end{array}\right.$$<br>解的表达式：<br>$$u(x, t)=\int</em>{-\infty}^{\infty} G(x-y, t) \varphi(y) \mathrm{d} y+\int_{0}^{t} \int_{-\infty}^{\infty} G(x-y, t-\tau) f(y, \tau) \mathrm{d} y \mathrm{d} \tau$$</p><h3 id="光滑性对比"><a href="#光滑性对比" class="headerlink" title="光滑性对比"></a>光滑性对比</h3><ol><li>波动方程光滑性与初始数据的光滑性相同。$u \in C^{2}</li><li>热方程的解具有很好的光滑性，$u \in C^{\infty}$</li></ol><h3 id="决定区域和影响区域对比"><a href="#决定区域和影响区域对比" class="headerlink" title="决定区域和影响区域对比"></a>决定区域和影响区域对比</h3><ol><li>波动方程，是斜率为$\alpha$的特征锥内部。</li><li>热方程影响区域是整个上半平面，扰动传播速度无限。</li></ol><h3 id="极值原理-1"><a href="#极值原理-1" class="headerlink" title="极值原理"></a>极值原理</h3><ol><li>热传导方程存在极值原理, 而波动方程没有极值原理.</li></ol><h1 id="椭圆形方程"><a href="#椭圆形方程" class="headerlink" title="椭圆形方程"></a>椭圆形方程</h1><h2 id="调和函数"><a href="#调和函数" class="headerlink" title="调和函数"></a>调和函数</h2><p>定义：在有界趋于$\Omega \in R^n$内有直到二阶的连续偏导数,  且在$\Omega$内满足$\Delta_nu=0$，则有基本解。<br>$$u(r)=\left{\begin{array}{ll}\ln \frac{1}{r}, &amp; n=2 \ \frac{1}{r^{n-2}}, &amp; n \geq 3\end{array}\right.$$</p><h3 id="极坐标"><a href="#极坐标" class="headerlink" title="极坐标"></a>极坐标</h3><p>对二维的Laplace算子, 在极坐标<br>$$ x = x_0 + r \cos \theta,\quad y = y_0 + r \sin \theta$$<br>变换下，有：<br>$$\Delta_{2} u=\frac{\partial^{2} u}{\partial r^{2}}+\frac{1}{r} \frac{\partial u}{\partial r}+\frac{1}{r^{2}} \frac{\partial^{2} u}{\partial \theta^{2}}$$</p><h2 id="Green公式"><a href="#Green公式" class="headerlink" title="Green公式"></a>Green公式</h2><h3 id="散度定理"><a href="#散度定理" class="headerlink" title="散度定理"></a>散度定理</h3><p>设$\Omega$时$n$维空间中足够光滑的曲面$\Gamma$所围成的有界连通区域。$v$是曲面的单位外法向量。若函数$P_i(x_1,\dots, x_n),(i=1,\dots,n)$在闭区域$\Omega + \Gamma$上连续，在$\Omega$上有一阶连续偏导。则：<br>$$\int_{\Omega} \sum_{i=1}^{n} \frac{\partial P_{i}}{\partial x_{i}} \mathrm{d} x_{1} \cdots \mathrm{d} x_{n}=\int_{\Gamma} \sum_{i=1}^{n} P_{i} \cos \left(\nu, x_{i}\right) \mathrm{d} S$$</p><p>由散度定理推第一，第二Green公式。<br>$u,v$有二阶连续偏导。令<br>$$P_{i}=u \frac{\partial v}{\partial x_{i}}, \quad i=1,2, \cdots, n$$<br>就有<br>$$\int \cdots \int_{\Omega} \sum_{i=1}^{n} \frac{\partial}{\partial x_{i}}\left(u \frac{\partial v}{\partial x_{i}}\right) \mathrm{d} x_{1} \cdots \mathrm{d} x_{n}=\int \cdots \int_{\Gamma} u \sum_{i=1}^{n} \frac{\partial v}{\partial x_{i}} \cos \left(\nu, x_{i}\right) \mathrm{d} S$$<br>可以用Laplace算子改写为<br>$$\int \cdots \int_{\Omega} u \Delta_{n} v \mathrm{d} \Omega+\int \cdots \int_{\Omega} \sum_{i=1}^{n} u_{x_{i}} v_{x_{i}} \mathrm{d} \Omega=\int \cdots \int_{\Gamma} u \frac{\partial v}{\partial \nu} \mathrm{d} S$$</p><p>第一Green公式<br>$$\int_{\Omega} v \Delta_n u d x=\int_{\partial \Omega} v \frac{\partial u}{\partial \vec{n}} \mathrm{d} S-\int_{\Omega} \nabla u \cdot \nabla v \mathrm{d} x$$<br>将$u,v$换位置，相减。<br>第二Green公式<br>$$\int_{\Omega}(u \Delta_n v-v \Delta_n u) \mathrm{d} \Omega=\int_{\partial \Omega}\left(u \frac{\partial v}{\partial n}-v \frac{\partial u}{\partial n}\right) \mathrm{d} S$$</p><h2 id="调和函数的平均值公式"><a href="#调和函数的平均值公式" class="headerlink" title="调和函数的平均值公式"></a>调和函数的平均值公式</h2><p>调和函数在其定义域 Ω 内任一点的值等于它在以该点为心且包含于 Ω 的球面（球体）上的平均值:<br>$$u(x)=\frac{1}{\left|\partial B_{R}(x)\right|} \int_{\alpha_{R}(x)} u \mathrm{d} S_{\xi}, \quad B_{R}(x) \subset \Omega$$<br>$$u(x)=\frac{1}{\left|B_{R}(x)\right|} \int_{B_{R}(x)} u(\xi) \mathrm{d} \xi, \quad B_{R}(x) \subset \Omega$$<br>可以用来计算$u$在某一点的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目录&lt;/p&gt;
&lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#基本概念&quot;&gt;基本概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二阶方程的特征理论和分类&quot;&gt;二阶方程的特征理论和分类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;!-- GFM-TOC --&gt;
    
    </summary>
    
    
    
      <category term="课程复习" scheme="sfarl.github.io/tags/%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="数学物理方程" scheme="sfarl.github.io/tags/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据库复习</title>
    <link href="sfarl.github.io/2020/06/29/%E5%A4%8D%E4%B9%A0/"/>
    <id>sfarl.github.io/2020/06/29/%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-06-29T09:36:28.000Z</published>
    <updated>2020-07-04T10:49:46.774Z</updated>
    
    <content type="html"><![CDATA[<p>这是本科数据库课程的复习。考试内容主要是数据库的基本概念，数据库设计数据库系统的优化和恢复。至于设计底层的数据库管理系统原理，坑先挖了，日后补，是我计划中的一门课程。</p><p>目录</p><!-- GFM-TOC --><ul><li><a href="#绪论">绪论</a></li><li><a href="#关系数据库">关系数据库</a></li><li><a href="#关系数据库标准语言SQL">SQL</a></li><li><a href="#关系查询和查询优化">关系查询和查询优化</a></li><li><a href="#数据库安全性">数据库安全性</a></li><li><a href="#数据库完整性">数据库完整性</a></li><li><a href="#数据库恢复技术">数据库恢复技术</a></li><li><a href="#并发控制">并发控制</a><!-- GFM-TOC --><a id="more"></a></li></ul><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><ol><li><strong>数据库系统</strong>：一般由数据库。数据库管理系统（及其开发工具）、应用系统、数据库管理员构成。目的：存储信息并支持用户检索和更新所需的信息。</li><li><strong>数据模型</strong>：是数据库中用来对现实世界数据特征的抽象的工具，是数据库中用于提供信息表示和操作手段的形式架构。<ul><li>三要素：数据结构，数据操作，完整性约束。</li></ul></li><li><strong>ER图</strong>：概念模型钟的一种，实体~属性</li><li><strong>三级模式结构</strong><ul><li>模式：（逻辑模式）数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。一个数据库只有一个模式。</li><li>外模式：（子模式/用户模式）数据库用户能够看见和使用的局部数据库和逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的系统的逻辑表示。</li><li>内模式：（存储模式或内视图）是数据物理结构和存储方式的描述，是数据在数据库内部实际存储的表示方式：</li><li>优点：数据独立性（逻辑，物理），数据安全性，数据操作简易。</li><li>二级映像功能和三级模式同。（模式映像对应外模式，内模式映像对应模式），保护数据独立性。</li><li>逻辑独立性：模式改变，但外模式不变，程序不变。</li><li>物理独立性：物理结构变化，但模式不变，程序不变。</li></ul></li></ol><h1 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h1><h2 id="关系数据三个组成部分。"><a href="#关系数据三个组成部分。" class="headerlink" title="关系数据三个组成部分。"></a>关系数据三个组成部分。</h2><ol><li><strong>关系数据结构</strong>：描述实体和实体间的关系。</li><li><strong>关系操作</strong>：<ul><li>查询操作：选择、投影、连接、除、并、差、交、笛卡尔积等。</li><li>插入、删除、修改操作。</li></ul></li><li><strong>关系完整性约束</strong>：<ul><li>实体完整性：若属性（指一个或一组属性）A是基本关系R的主属性， A不能取空值。</li><li>参照完整性：若属性（或属性组）F是基本关系R的外码，它是基本关系S的主码K相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为：或者取空值（F的每个属性值均为空值）；或者等于S中某个元组的主码值。</li></ul></li></ol><h2 id="码"><a href="#码" class="headerlink" title="码"></a>码</h2><ol><li>候选码：若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码。</li><li>主属性：候选码的属性称为主属性，不包含在任何侯选码中的属性称为非主属性。</li><li>超码：关系中能唯一标识元组的属性集，超码的任意超集仍是超码。</li><li>主码：若一个关系有多个候选码，则选定期中一个为主码。</li><li>外码：设F是基本关系R的一个或一组属性。但不是关系R的码，如果F与基本关系S的主码K相对应。</li></ol><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><ol><li>集合运算：交，并，差，笛卡尔积。</li><li>逻辑运算：非，与，或。</li><li><strong>关系运算</strong>：选择，投影<ul><li>连接：等值连接，自然连接，外连接（左，右）</li><li><strong>除</strong>：给定关系R (X，Y) 和S (Y，Z)，其中X，Y，Z为属性组；R中的Y与S 中的Y可以有不同的属性名，但必须出自相同的域集；R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在 X 属性列上的投影。</li></ul></li></ol><h2 id="关系数据库理论"><a href="#关系数据库理论" class="headerlink" title="关系数据库理论"></a>关系数据库理论</h2><ol><li>函数依赖：设R(U)是一个属性集U上的关系模式，X和Y是U的子集， 若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称 “X函数确定Y” 或  “Y函数依赖于X”，记作X$\rightarrow$Y。 </li><li>完全函数依赖：$x \rightarrow y$, 任意x的子集$x^s$, $x^s \not \rightarrow y$.</li><li>部分函数依赖:$x \rightarrow y$, 存在x的子集$x^s$, $x^s \not \rightarrow y$.</li><li>传递函数依赖：$x \rightarrow y$， $y \not \in x$, $y \not \rightarrow x$, $y \not \rightarrow z$, $z \not \in y$, 则称Z对X传递函数依赖.</li><li>候选码：K完全函数决定该关系的所有其它属性。K的任何真子集都不能完全函数决定R的所有其它属性。</li><li>外部码：</li></ol><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li>1NF：一个关系模式R的所有属性都是不可分的基本数据项.</li><li>2NF：若R$\in$ 1NF，且每一个非主属性完全函数依赖于码.</li><li>3NF：每个非主属性都不传递依赖于R的码。</li><li>BCNF：关系模式R&lt;U，F&gt;$\in$ 1NF，若X$\rightarrow$Y且Y $\not \rightarrow$ X时X必含有码，即每个属性都不传递依赖于R的码，则R&lt;U，F&gt; $\in$BCNF</li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li>1NF存在插入异常、删除异常、数据冗余度大、修改复杂等问题。</li><li>将一个1NF关系分解为多个2NF的关系，并不能完全消除关系模式中的各种异常情况和数据冗余。</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol><li>不是BCNF但是3NF：关系模式STJ（S,T,J）中，S是学生，T是教师，J是课程。每一教师只教一门课，每门课有若干教师，某一学生选定某课程，就得到一个固定的教师。<br>函数依赖：（S,J）决定T;（S,T）决定J;T决定J;<br>这里候选码（S,J），（S,T）；<br>不存在非主属性对码的部分或传递函数依赖，所以STJ属于第三范式；<br>但是J部分函数依赖于码（T,S），T不是码，所以STJ不属于BCNF。</li></ol><h1 id="关系数据库标准语言SQL"><a href="#关系数据库标准语言SQL" class="headerlink" title="关系数据库标准语言SQL"></a>关系数据库标准语言SQL</h1><ol><li>数据定义：定义数据库中的基本对象、模式(架构)定义、表定义、视图和索引。<ul><li>CASCADE(级联)：删除模式的同时把该模式中所有的数据库对象全部删除</li><li>RESTRICT(限制); 没有任何下属的对象时 才能执行。</li></ul></li><li>索引：建立索引的目的：加快查询速度。<ul><li>CLUSTER表示要建立的索引是聚簇索引。索引项顺序与表中记录的物理顺序一致。 </li></ul></li><li>数据查询<ul><li>BETWEEN … AND 包括头尾</li><li>like str的模糊查询</li><li>逻辑运算优先级：and先于or</li></ul></li><li>数据更新 (insert), 修改 (update), 删除</li><li>视图:虚表，是从一个或几个基本表（或视图）导出的表；只存放视图的定义，不存放视图对应的数据；基表中的数据发生变化，从视图中查询出的数据也随之改变。</li></ol><h1 id="关系查询和查询优化"><a href="#关系查询和查询优化" class="headerlink" title="关系查询和查询优化"></a>关系查询和查询优化</h1><h2 id="查询处理"><a href="#查询处理" class="headerlink" title="查询处理"></a>查询处理</h2><ol><li>步骤<ul><li>查询分析：查询语句是否符合语法规则。</li><li>查询检查：语句中对象的检查和简单的完整性检查。转化为关系代数表达式（查询树）。</li><li>查询优化：对关系代数表达式进行等价变换，基于规则，代价，语义。</li><li>查询执行：根据优化后的执行策略生成执行计划，由代码生成器生成执行计划的代码，返回查询结果。</li></ul></li><li>查询操作的算法（这方面考试我觉得不会考，但坑先挖下，之后回来补，这方面还是挺感兴趣的。）<ul><li>选择操作算法<ol><li>全表扫描</li><li>索引扫描（B+树，hash表）</li></ol></li><li>连接操作算法<ol><li>嵌套循环</li><li>排序合并</li><li>索引连接</li><li>hash join</li></ol></li></ul></li><li>查询优化：不仅仅在于不需要考虑如何实现，还在于系统可以比用户优化的更好。</li><li>代数优化（总结一些规律）<ul><li>优先做选择</li><li>投影和选择可同时进行</li><li>投影和双目运算结合</li><li>笛卡尔积和选择合并成一个连接</li></ul></li><li>物理优化<ul><li>基于规则的启发式：总结一些优化方案</li><li>基于代价估算：简单的io估算</li><li>上述结合</li></ul></li></ol><h1 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ol><li>数据库的安全性是指保护数据库以防止非法使用所造成的数据泄漏、更改或破坏。</li><li>数据库安全控制的常用方法和技术。<ul><li>用户标识和鉴别</li><li>存取控制：通过用户权限定义和合法权限检查确保只有拥有合法权限的用户才能访问数据库，所有未授权人员均无法存取数据。</li><li>视图机制：</li><li>审计：建立审计日志，把用户对数据库的所有操作自动记录下来并放入审计日志中。DBA可以利用审计跟踪信息来重现导致数据库现状的一系列事件，找出非法存取数据的人、时间和内容等。</li><li>数据加密</li></ul></li></ol><h2 id="存储控制"><a href="#存储控制" class="headerlink" title="存储控制"></a>存储控制</h2><ol><li>自主存取控制方法：定义各个用户对不同数据对象的存取权限。当用户要访问数据库时，首先要检查其存取权限，以防止非法用户对数据库进行存取。</li><li>强制存取控制方法：每一个数据对象被（强制地）标以一定的加密级别，每位用户也被（强制地）授予某一级别的许可证。系统规定只有具有某一许可证级别的用户才能存取加密级别的数据对象。</li><li>自主存取控制语句：授权与收回语句。GRANT 语句和 REVOKE 语句实现。</li></ol><h1 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><ol><li>数据完整性：数据的正确性和相容性。</li><li>完整性约束：定义，检查，违约反映</li><li>参照完整性</li></ol><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><ol><li>一旦定义，任何用户对表的增删改，均由服务器自动激活触发器，进行集中的完整性控制；可以进行更为复杂的检查和操作，具有更精细和更强大的数据控制能力。</li></ol><h1 id="数据库恢复技术"><a href="#数据库恢复技术" class="headerlink" title="数据库恢复技术"></a>数据库恢复技术</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>事务：事务是用户所定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。ACID特性。<ul><li>原子性：事务是数据库的逻辑单位，事务中所包括的读项操作要么都做，要么都不做。</li><li>一致性：事务执行的结果必须是使数据库从某个一致性状态转变到另一个一致性状态。</li><li>隔离性：一个事务的执行不能被其他事务干扰，即一个事务内部的操作及所试用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>持续性：（永久性）事务一旦提交，它对数据库中主句的改变就应该是永久的。接下来的其他操作不应对其执行结果产生任何影响。</li></ul></li><li>为了保证事务的原子性、一致性与持续性。DBMS必须对事务故障、系统故障和介质故障进行恢复；为了保证事务的隔离性和一致性，DBMS需要对并发操作进行控制。</li><li>日志：日志文件是用来记录事务对数据库所做的更新操作的文件。<ul><li>目的：进行事务故障恢复；进行系统故障恢复；协助后背副本进行故障恢复。</li><li>作用：1、事务故障恢复和系统故障恢复必须用到日志文件。2.在动态转储方式中必须建立日志文件，后备副本和日志文件结合起来才能有效地恢复数据库。3、在静态转储方式中，也可以建立日志文件。当数据库毁坏后可重新装入后援副本把数据库恢复到转储结束时刻的正确状态，然后利用日志文件，把已完成的事务进行重做处理，对故障发生时尚未完成的事务进行撤销处理。</li><li>登记原则：1、登记的次序严格按并发事务执行的时间测序。2、必须先写日志文件，后写数据库。</li></ul></li></ol><h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><ol><li>事务故障恢复步骤：<ul><li>反向扫描日志文件。</li><li>对更新进行逆操作。</li></ul></li><li>系统故障恢复步骤：<ul><li>正向扫描日志文件。</li><li>找出重做队列（redo），撤销队列（undo）</li></ul></li><li>检查点（checkpoint）：显著改善恢复效率。</li></ol><h1 id="数据并发控制"><a href="#数据并发控制" class="headerlink" title="数据并发控制"></a>数据并发控制</h1><ol><li>并发控制可以保证事务的一致性和隔离性，保证数据库的一致性。</li><li>并发操作可能导致的问题：<ul><li>丢失修改：两个事务1、2同时读入同意数据并进行修改，2所提交的结果破坏（覆盖）了1提交的结果，导致1所做的修改被丢失。</li><li>不可重复读：事务1读取某一数据后，事务2对其执行更新操作，使1无法再现前一次读取的结果。</li><li>读‘脏’数据：事务1修改某一数据，将其协会磁盘，事务2读取同意数据后，事务1由于某种原因被撤销，这是事务1已修改过的数据将恢复原值，事务2所读取的数据就与数据库中的数据不一致，则事务2所独到的就是‘脏’数据，即不正确的数据。</li><li>避免不一致性的方法是并发控制机制。最常用的并发控制技术是封锁技术。</li></ul></li><li>锁<ul><li>写锁（排他锁）X</li><li>读锁（共享锁）S</li></ul></li><li>封锁协议<ul><li>一级封锁：修改之前加X锁，事务结束释放。</li><li>二级封锁：读之前加S锁，读完就释放。</li><li>三级封锁：读之前加S锁，事务结束释放。</li></ul></li><li>活锁和死锁。<ul><li>先来先服务解决活锁</li><li>死锁可以采取一次封锁或顺序封锁避免，但会降低性能。通常做法允许死锁，然后杀死某一事务。</li></ul></li><li>并发调度的可串行性：事务并发是正确的当且仅当结果和串行执行时一致。</li><li>冲突可串行化：只要可以通过不冲突操作得到串行调度（冲突操作：不同事务对同一个数据的读写操作和写写操作）。</li><li>两段锁<ul><li>数据读写前要申请对数据的封锁。</li><li>释放封锁后，不再申请和获得其他锁。</li><li>若并发执行的所有事务均遵守两段锁协议，则调度是可串行化的。</li></ul></li><li>意向锁：对节点加意向锁，表示节点的下层节点正在加锁。（IS,IX,SIX)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本科数据库课程的复习。考试内容主要是数据库的基本概念，数据库设计数据库系统的优化和恢复。至于设计底层的数据库管理系统原理，坑先挖了，日后补，是我计划中的一门课程。&lt;/p&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#绪论&quot;&gt;绪论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#关系数据库&quot;&gt;关系数据库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#关系数据库标准语言SQL&quot;&gt;SQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#关系查询和查询优化&quot;&gt;关系查询和查询优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#数据库安全性&quot;&gt;数据库安全性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#数据库完整性&quot;&gt;数据库完整性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#数据库恢复技术&quot;&gt;数据库恢复技术&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#并发控制&quot;&gt;并发控制&lt;/a&gt;&lt;!-- GFM-TOC --&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="sfarl.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="课程复习" scheme="sfarl.github.io/tags/%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据挖掘课程设计</title>
    <link href="sfarl.github.io/2020/06/27/dataming_project/"/>
    <id>sfarl.github.io/2020/06/27/dataming_project/</id>
    <published>2020-06-27T09:36:28.000Z</published>
    <updated>2020-06-27T11:40:14.743Z</updated>
    
    <content type="html"><![CDATA[<p>最近结束了数据挖掘的课程设计，做的内容比较简单，是MNIST手写数据集的识别（课程要求），这篇主要是写写其中的一些心得和体会。</p><p>项目是我和彭同学一起做的，两个人，他负责用SVM识别，我用MLP和CNN，下面的心得体会是我和他的共同体会，SVM部分的体会来自于他，神经网络部分来自我。</p><a id="more"></a><h1 id="方法和结果"><a href="#方法和结果" class="headerlink" title="方法和结果"></a>方法和结果</h1><ol><li>MNIST数据集的导入可以自行google或百度。</li><li>SVM部分采用的是OvR，原因是参数调整和训练时长。调参，通过五折交叉检验确定搜索区间，然后用网格搜索对惩罚系数C和RBF函数的gamma参数进行搜索。训练时长12分钟，测试集准确率97%.</li><li>MLP是四层，参数601610个。CNN三层卷积一层池化，参数2845个。调参是通过先调层数，再调学习率，最后调权重衰减。训练时间MLP10s一个epoch，10轮左右接近98%，损失函数接近0。CNN20s一个epoch，15轮左右接近97%。损失函数30个epoch到不了0。MLP无论是准确率还是收敛速度，训练时间都比CNN好。<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></li><li>可通过learning curve找肘点选取适当的参数，样本量太大时可选择部分样本进行参数调整——因为若参数得当，在少样本上的最优参数在大样本上也极有可能是最优；</li><li>SVM多分类常用OvO，因其样本不平衡问题没有OvR那么突出。但SVM用于分类问题在于训练和检测代价过高，而且难以应用到流式数据中（特别是OvR的SVM，在输入新数据时需要重新训练所有模型！）。所以SVM在工业界或许难以有效应用；</li><li>深度学习算法调参比较困难，算法理论基础不及SVM的完善。但参数调整好后，训练和检测代价都会与样本量接近线性关系，也能较好地适应流式数据。同时神经网络用Hierarchical Softmax、Subsampling、对稀疏的样本数据可以分布式学习等技巧来优化训练速度和质量，具有较强的拓展性。</li><li>先了解数据，包括数据的构成，大小，缺失，特征等。若有可能，对数据进行简单可视化。</li><li>可先抽取少部分数据集，检验代码是否正常运行，和调整模型参数。</li><li>模型的选取可先从简单模型开始，作为一个baseline，模型简单并不意味着效果不好。</li><li>神经网络的设计优先设计结构，模型的复杂度体现在网络结构中。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近结束了数据挖掘的课程设计，做的内容比较简单，是MNIST手写数据集的识别（课程要求），这篇主要是写写其中的一些心得和体会。&lt;/p&gt;
&lt;p&gt;项目是我和彭同学一起做的，两个人，他负责用SVM识别，我用MLP和CNN，下面的心得体会是我和他的共同体会，SVM部分的体会来自于他，神经网络部分来自我。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据挖掘" scheme="sfarl.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="课程设计" scheme="sfarl.github.io/tags/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>csapp lab1 datalab</title>
    <link href="sfarl.github.io/2020/06/20/csapp%20lab1/"/>
    <id>sfarl.github.io/2020/06/20/csapp%20lab1/</id>
    <published>2020-06-20T09:36:28.000Z</published>
    <updated>2020-06-20T09:55:01.366Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LAB-1"><a href="#LAB-1" class="headerlink" title="LAB 1"></a>LAB 1</h3><p>这一个 lab 主要涉及了位运算，补码和浮点数等内容。个人觉得不算容易，因为限定了算子和操作数,从比特的层面实现一些功能。</p><h4 id="1-用非和且实现异或"><a href="#1-用非和且实现异或" class="headerlink" title="1. 用非和且实现异或"></a>1. 用非和且实现异或</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 异或，按位取反后取且</span></span><br><span class="line">  <span class="keyword">return</span> (~x&amp;y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="2-输出补码中最小的int"><a href="#2-输出补码中最小的int" class="headerlink" title="2.输出补码中最小的int"></a>2.输出补码中最小的int</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 因为10..0对应的是tmin</span></span><br><span class="line">  <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (t &lt;&lt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-判断是否是int——max"><a href="#3-判断是否是int——max" class="headerlink" title="3.判断是否是int——max"></a>3.判断是否是int——max</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two's complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// max 是011...1,加1是tmin，相加等于负1，然后+1再取非.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">return</span> !(x + (x+<span class="number">1</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-判断奇数位-级数次方对应的位）比特是否全为1"><a href="#4-判断奇数位-级数次方对应的位）比特是否全为1" class="headerlink" title="4.判断奇数位(级数次方对应的位）比特是否全为1"></a>4.判断奇数位(级数次方对应的位）比特是否全为1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 所有级数位全为1，则和偶数位全为1的并是全1，再取反全0，再取非是1.</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> b = a + (a&lt;&lt;<span class="number">4</span>) + (a&lt;&lt;<span class="number">8</span>) + (a&lt;&lt;<span class="number">16</span>) + (a&lt;&lt;<span class="number">24</span>);</span><br><span class="line">  <span class="keyword">return</span> !~(b|x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个还想了挺久。</p><h4 id="5-取负数"><a href="#5-取负数" class="headerlink" title="5.取负数"></a>5.取负数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 按位取反后相差负一，补上个1即可。</span></span><br><span class="line">  <span class="keyword">return</span> (~x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-判断ASCII码"><a href="#6-判断ASCII码" class="headerlink" title="6.判断ASCII码"></a>6.判断ASCII码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9')</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在这中间的，两个判断语句的符号位都是0，右移31，全为0.</span></span><br><span class="line">  <span class="keyword">return</span> !(((x<span class="number">-0x30</span>)&gt;&gt;<span class="number">31</span>) | ((<span class="number">0x39</span>-x)&gt;&gt;<span class="number">31</span>) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-条件语句"><a href="#7-条件语句" class="headerlink" title="7.条件语句"></a>7.条件语句</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 只说左边，右边一样。目标是x取0时，输出0，x取其他时，输出y</span></span><br><span class="line">  <span class="comment">// 首先！x。！x=1, 1-1=0, 一交就是0了，！x=0，-1的二进制是111..，和x交等于x</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">return</span> ((!x<span class="number">-1</span>) &amp; y) | ((~!x - <span class="number">1</span>) &amp; z);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题也卡了一小会，主要是利用-1那一开始没想到。</p><h4 id="8-小于等于"><a href="#8-小于等于" class="headerlink" title="8.小于等于"></a>8.小于等于</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 右减左，然后左移31位，取非即可。</span></span><br><span class="line">  <span class="keyword">return</span> !((y-x)&gt;&gt;<span class="number">31</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-逻辑非"><a href="#9-逻辑非" class="headerlink" title="9.逻辑非"></a>9.逻辑非</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 要把0分离出来，0的特性~0+1=0，所以想到了利用这点，其他的数(~x+1)|x肯定是负数，</span></span><br><span class="line">  <span class="comment">// 右移31，得到-1，然后和1交即可。</span></span><br><span class="line">  <span class="keyword">return</span> (((~x+<span class="number">1</span>)|x) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-统计比特数"><a href="#10-统计比特数" class="headerlink" title="10.统计比特数"></a>10.统计比特数</h4><p>太难了，我倒下了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two's complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-浮点数乘2"><a href="#11-浮点数乘2" class="headerlink" title="11.浮点数乘2"></a>11.浮点数乘2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 阶数等于0xff返回本身,inf和nan</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> temp = uf;</span><br><span class="line">  <span class="comment">// 分别取出阶数和符号位和分数</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">exp</span> = uf &amp; <span class="number">0x7f80000</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> sign = (uf&gt;&gt;<span class="number">31</span>)&lt;&lt;<span class="number">31</span> ;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> frac = uf &amp; <span class="number">0x007fffff</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 去除符号</span></span><br><span class="line">  temp = temp &amp; <span class="number">0x7fffffff</span></span><br><span class="line">  <span class="comment">// 情况1：对非规格化数据，只需要分数位左移一位即可。</span></span><br><span class="line">  <span class="keyword">if</span> ((temp&gt;&gt;<span class="number">23</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">    temp = (temp&lt;&lt;<span class="number">1</span>) | sign;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((temp&gt;&gt;<span class="number">23</span>) == <span class="number">0xff</span>) &#123;</span><br><span class="line">    <span class="comment">// 这是对inf和nan数据</span></span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 最后对于规格化数据，阶数+1</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">exp</span>&gt;&gt;<span class="number">23</span> +<span class="number">1</span>) | f | sign</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-float-2-int"><a href="#12-float-2-int" class="headerlink" title="12.float 2 int"></a>12.float 2 int</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 阶数等于0xff和0x00返回0x80000000u,inf和nan</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> temp = uf;</span><br><span class="line">  <span class="comment">// 分别取出阶数和符号位和分数</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">exp</span> = uf &amp; <span class="number">0x7f80000</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> sign = (uf&gt;&gt;<span class="number">31</span>)&lt;&lt;<span class="number">31</span> ;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> frac = uf &amp; <span class="number">0x007fffff</span></span><br><span class="line">   <span class="comment">// 去除符号</span></span><br><span class="line">  temp = temp &amp; <span class="number">0x7fffffff</span> </span><br><span class="line">  <span class="comment">// 若是非规格化数据，返回0</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="built_in">exp</span>&gt;&gt;<span class="number">23</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x0</span>u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 阶数等于0xff和0x00返回0x80000000u</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((temp&gt;&gt;<span class="number">23</span>) == <span class="number">0xff</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 阶数大于0，左移对应阶数。</span></span><br><span class="line">    <span class="keyword">if</span> (((<span class="built_in">exp</span>&gt;&gt;<span class="number">23</span>)<span class="number">-127</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> sign|(frac&lt;&lt;((<span class="built_in">exp</span>&gt;&gt;<span class="number">23</span>)<span class="number">-127</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阶数等于0，非规格化数据，直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> (((<span class="built_in">exp</span>&gt;&gt;<span class="number">23</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> sign | <span class="number">0x0</span>u</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阶数小于0，右移对应阶数。我选择的舍入是向取整。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (((<span class="built_in">exp</span>&gt;&gt;<span class="number">23</span>)<span class="number">-127</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> sign|(frac&gt;&gt;(-((<span class="built_in">exp</span>&gt;&gt;<span class="number">23</span>)<span class="number">-127</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-2的整数幂次，关键在于确定范围。"><a href="#13-2的整数幂次，关键在于确定范围。" class="headerlink" title="13.2的整数幂次，关键在于确定范围。"></a>13.2的整数幂次，关键在于确定范围。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先给出2</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> temp = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">exp</span> = (<span class="number">1</span>&lt;&lt;<span class="number">23</span>)+<span class="number">127</span>;</span><br><span class="line">  <span class="keyword">int</span> sign = (x&gt;&gt;<span class="number">31</span>)&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> value = x &amp; <span class="number">0x7fffffff</span>;</span><br><span class="line">  <span class="comment">// 负数，2右移</span></span><br><span class="line">  <span class="keyword">if</span> (sign == <span class="number">0xffffffff</span>)&#123;</span><br><span class="line">    <span class="comment">// 太小了，直接返回0；</span></span><br><span class="line">    <span class="keyword">if</span> (value &gt; <span class="number">127</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 范围内，减去幂次，然后并起来。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">exp</span> = <span class="built_in">exp</span> - (value&lt;&lt;<span class="number">23</span>);</span><br><span class="line">      <span class="keyword">return</span> (temp|<span class="built_in">exp</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="number">0x00000000</span>)&#123;</span><br><span class="line">    <span class="comment">// 太大了，溢出,返回inf</span></span><br><span class="line">    <span class="keyword">if</span> (value &gt; <span class="number">127</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> (temp|(<span class="number">256</span>&lt;&lt;<span class="number">23</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 范围内，加上幂次，</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">exp</span> = <span class="built_in">exp</span> + (value&lt;&lt;<span class="number">23</span>);</span><br><span class="line">      <span class="keyword">return</span> (temp|<span class="built_in">exp</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一章主要讲的是二进制对数据的表示和数学运算。难度我觉得挺难的，主要是当限制到底层，用二进制实现一些在数学定义好的操作上，需要一个思维的转换过程.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;LAB-1&quot;&gt;&lt;a href=&quot;#LAB-1&quot; class=&quot;headerlink&quot; title=&quot;LAB 1&quot;&gt;&lt;/a&gt;LAB 1&lt;/h3&gt;&lt;p&gt;这一个 lab 主要涉及了位运算，补码和浮点数等内容。个人觉得不算容易，因为限定了算子和操作数,从比特的层面实现一些功能。&lt;/p&gt;
&lt;h4 id=&quot;1-用非和且实现异或&quot;&gt;&lt;a href=&quot;#1-用非和且实现异或&quot; class=&quot;headerlink&quot; title=&quot;1. 用非和且实现异或&quot;&gt;&lt;/a&gt;1. 用非和且实现异或&lt;/h4&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * bitXor - x^y using only ~ and &amp;amp; &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *   Example: bitXor(4, 5) = 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *   Legal ops: ~ &amp;amp;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *   Max ops: 14&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *   Rating: 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bitXor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 异或，按位取反后取且&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (~x&amp;amp;y);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="lab" scheme="sfarl.github.io/tags/lab/"/>
    
      <category term="csapp" scheme="sfarl.github.io/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>csapp_chapter1</title>
    <link href="sfarl.github.io/2020/06/13/csapp-chapter1/"/>
    <id>sfarl.github.io/2020/06/13/csapp-chapter1/</id>
    <published>2020-06-13T11:24:20.000Z</published>
    <updated>2020-06-14T09:30:39.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-和-CMU-Introduction-to-computer-system-CS-15-213-2015-fall-的笔记。"><a href="#CSAPP-和-CMU-Introduction-to-computer-system-CS-15-213-2015-fall-的笔记。" class="headerlink" title="CSAPP 和 CMU Introduction to computer system (CS 15-213 2015 fall) 的笔记。"></a>CSAPP 和 CMU Introduction to computer system (<a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/index.html" target="_blank" rel="noopener">CS 15-213</a> 2015 fall) 的笔记。</h1><p>相关资料</p><ol><li><a href="http://csapp.cs.cmu.edu/3e/students.html" target="_blank" rel="noopener">Textbook</a></li><li><a href="https://www.zhihu.com/question/30315894" target="_blank" rel="noopener">在vscode上使用C</a><h2 id="1-COURSE-OVERVIEW"><a href="#1-COURSE-OVERVIEW" class="headerlink" title="1.COURSE-OVERVIEW"></a>1.COURSE-OVERVIEW</h2>从编程者的角度来讲述计算机系统。这也是为什么我第一门课选择这个的原因，因为自己是数学系的，之前学习的内容主要是偏向于算法和一些比较抽象的编程，没这么关注到计算机的底层实现（也许是大计基没上心。。。）所以选择这门课做为第一门补充课，希望能对计算机系统有个整体的认识，虽说自己之后是打算做数据挖掘，但对于基础的东西个人觉得还是需要有所了解。</li></ol><h3 id="主要内容包括："><a href="#主要内容包括：" class="headerlink" title="主要内容包括："></a>主要内容包括：</h3><ol><li>COMPUTER ARITHMETIC (计算机算术规则)</li><li>ASSEMBLY (汇编)</li><li>MEMORY (内存)</li><li>ASYMPTOTIC COMPLEXITY (渐近性?)</li><li>IO (写入写出)</li></ol><a id="more"></a><h3 id="一些重要的概念："><a href="#一些重要的概念：" class="headerlink" title="一些重要的概念："></a>一些重要的概念：</h3><ol><li><p>Amdahl 定律</p><p>  系统某部分执行时间和总时间比例为$\alpha$，而该部分性能提升为$k$，可计算加速比S</p>  <!-- ![](http://latex.codecogs.com/gif.latex?\\S=\frac{T_{old}}{T_{new}} =\frac{1}{(1-\alpha)+\alpha / k}) --><p>  $$S=\frac{T_{old}}{T_{new}} =\frac{1}{(1-\alpha)+\alpha / k}$$</p></li><li><p>并发和并行</p><ul><li>并发(concurrancy):同时具有多个活动的系统。</li><li>并行(parallelism):使用并发来使系统运行更快。</li></ul></li><li><p>一些抽象</p><ul><li>文件是 I/O  设备的抽象。</li><li>虚拟内存是程序存储器的抽象。</li><li>进程(process)是正在运行程序的抽象。</li><li>虚拟机是整个计算机的抽象。</li></ul></li></ol><h2 id="2-BITS-BYTES-INTEGER-float"><a href="#2-BITS-BYTES-INTEGER-float" class="headerlink" title="2.BITS,BYTES,INTEGER,float"></a>2.BITS,BYTES,INTEGER,float</h2><h3 id="BITS-AND-BYTES"><a href="#BITS-AND-BYTES" class="headerlink" title="BITS AND BYTES"></a>BITS AND BYTES</h3><ol><li>布尔代数的and, or, not, Xor运算形成布尔环(代数中的环）。</li><li>集合运算的Intersection, Union, Symmetric difference, Complement。</li><li>逻辑运算的&amp;&amp;, ||, !.</li><li>左移(left shift): 补0。 右移：逻辑右移补0，算术右移根据补码补0/1.</li></ol><h3 id="INT"><a href="#INT" class="headerlink" title="INT"></a>INT</h3><ol><li>represent<ul><li>Unsigned 和 Two’s Complement (补码)。</li><li>Range: $2^w-1$ 和 $[-2^{w-1}, 2^{w-1}-1]$</li><li>无符号整型和补码之间的关系.<img src="/assets/photos/bits_T2U.png" alt=""></li><li>扩张和截断，扩张是填充符号位，截断是取模。</li></ul></li><li>arithmetic<ul><li>对于加减乘，因为会溢出，通常的做法不是扩大存储的字节，而是阶段取模。</li><li>$u*2^k = u &lt;&lt; k$ 乘法左移，除法右移。</li></ul></li><li>内存可以看作是一个大的线性数组，每个地方都有对应的地址。</li></ol><h3 id="Float"><a href="#Float" class="headerlink" title="Float"></a>Float</h3><ol><li><p>IEEE float:<br>  $$(-1)^{S}\ \mathrm{M}\  2^{\mathrm{E}}$$</p><ul><li><p>S 决定正负，M是[1.0, 2.0)的二进制小数，E决定阶数。<br>以32位的float为例，0-22位是frac，即M; 23-30位是exp,$E = exp - bias$, 其中$bias = 2^{k-1} -1$, 这样做的好处是exp变为unsign的了；31位是S。</p></li><li><p>根据exp的值，分为规格化(normalized)， 非规格化(denormalized(阶码全为0)), 和特殊值(infinity(阶码全1，分数为0), nan(阶码全1，分数不为0)).</p></li><li><p>注意到浮点数的分布越趋于0越密集。</p></li></ul></li><li><p>舍入(rounding) 默认向偶数舍入。</p></li><li><p>arithmetic</p><ul><li>加：可交换不可结合(大数吃小数)，Abelian Group. 有单调性。</li><li>移位对其后加减</li><li>乘：可交换不可结合</li><li>$\mathrm{S} 1^{\wedge} \mathrm{S} 2$， $\mathrm{M} 1 \times \mathrm{M} 2$， $E 1+E 2$</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSAPP-和-CMU-Introduction-to-computer-system-CS-15-213-2015-fall-的笔记。&quot;&gt;&lt;a href=&quot;#CSAPP-和-CMU-Introduction-to-computer-system-CS-15-213-2015-fall-的笔记。&quot; class=&quot;headerlink&quot; title=&quot;CSAPP 和 CMU Introduction to computer system (CS 15-213 2015 fall) 的笔记。&quot;&gt;&lt;/a&gt;CSAPP 和 CMU Introduction to computer system (&lt;a href=&quot;http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CS 15-213&lt;/a&gt; 2015 fall) 的笔记。&lt;/h1&gt;&lt;p&gt;相关资料&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://csapp.cs.cmu.edu/3e/students.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Textbook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/30315894&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在vscode上使用C&lt;/a&gt;&lt;h2 id=&quot;1-COURSE-OVERVIEW&quot;&gt;&lt;a href=&quot;#1-COURSE-OVERVIEW&quot; class=&quot;headerlink&quot; title=&quot;1.COURSE-OVERVIEW&quot;&gt;&lt;/a&gt;1.COURSE-OVERVIEW&lt;/h2&gt;从编程者的角度来讲述计算机系统。这也是为什么我第一门课选择这个的原因，因为自己是数学系的，之前学习的内容主要是偏向于算法和一些比较抽象的编程，没这么关注到计算机的底层实现（也许是大计基没上心。。。）所以选择这门课做为第一门补充课，希望能对计算机系统有个整体的认识，虽说自己之后是打算做数据挖掘，但对于基础的东西个人觉得还是需要有所了解。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;主要内容包括：&quot;&gt;&lt;a href=&quot;#主要内容包括：&quot; class=&quot;headerlink&quot; title=&quot;主要内容包括：&quot;&gt;&lt;/a&gt;主要内容包括：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;COMPUTER ARITHMETIC (计算机算术规则)&lt;/li&gt;
&lt;li&gt;ASSEMBLY (汇编)&lt;/li&gt;
&lt;li&gt;MEMORY (内存)&lt;/li&gt;
&lt;li&gt;ASYMPTOTIC COMPLEXITY (渐近性?)&lt;/li&gt;
&lt;li&gt;IO (写入写出)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="网课" scheme="sfarl.github.io/tags/%E7%BD%91%E8%AF%BE/"/>
    
      <category term="CSAPP" scheme="sfarl.github.io/tags/CSAPP/"/>
    
      <category term="第一章" scheme="sfarl.github.io/tags/%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用github和hexo搭建博客</title>
    <link href="sfarl.github.io/2020/06/05/git/"/>
    <id>sfarl.github.io/2020/06/05/git/</id>
    <published>2020-06-05T00:56:45.000Z</published>
    <updated>2020-06-13T11:55:21.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>为什么是windows下呢，其实linux我也在虚拟机上对比过，发现git bash 和ubuntu 的命令行是没什么区别的（应该说是我没发现问题，毕竟用的比较浅。)</p><p>git bash的安装和使用可以看这个<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">git-pro</a>这是我个人觉得非常好的介绍，有中文版。</p><p>关于命令行的操作，git bash的使用和linux的控制台一致，入门可以看这<a href="https://missing-semester-cn.github.io" target="_blank" rel="noopener">The Missing Semester of Your CS Education</a>，带有中文版，视频可以在b站上面找。反正我学完后日常操作没碰到什么困难。</p><p>有了这两个，git bash的操作就没问题了。</p><a id="more"></a><h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><p>hexo博客的搭建我主要是基于这篇博客<a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa#hexo-jian-jie" target="_blank" rel="noopener">使用hexo+github搭建免费个人博客详细教程</a>我就不过多的重复了。</p><p>补充一些上述博客没提到的点。</p><ol><li>md是markdown文件，我目前使用的编辑器是atom，优点是插件众多，git hub直连，但有一个很明显的缺点，中文输入有bug，经常按了键盘没反应，也没找到相关的解决方案，希望能解决，不行就转vscode了。</li><li>博客主题，<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a>已经几年没更新了，有网友基于yilia，建了<a href="https://github.com/JoeyBling/hexo-theme-yilia-plus" target="_blank" rel="noopener">yilia-plus</a>,可以直接采用yilia-plus，blog的配置，在根目录的config，和theme/yilia-plus/下的config下面修改。</li><li>我现在改用vscode了，非常流畅，包也齐全。不用再受atom输入的气了！！！</li><li>我换yilia-plus了。</li></ol>]]></content>
    
    <summary type="html">
    
      windows下git和hexo的配置。
    
    </summary>
    
    
    
      <category term="博客搭建" scheme="sfarl.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
      <category term="git" scheme="sfarl.github.io/tags/git/"/>
    
      <category term="hexo" scheme="sfarl.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>大家好哇</title>
    <link href="sfarl.github.io/2020/06/04/hello-world/"/>
    <id>sfarl.github.io/2020/06/04/hello-world/</id>
    <published>2020-06-04T07:22:11.211Z</published>
    <updated>2020-06-05T01:01:18.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一篇博客，介绍一下自己写博客的初衷。"><a href="#第一篇博客，介绍一下自己写博客的初衷。" class="headerlink" title="第一篇博客，介绍一下自己写博客的初衷。"></a>第一篇博客，介绍一下自己写博客的初衷。</h2><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>其实我想写博客的想法很久之前就有了，但因为各种各样的原因耽误了，其实主要是自己不迫切。想记录一些自己的生活，学习心得，同时锻炼自己的文笔。大学以后，生活虽说多姿多彩，但偶尔回望记得却不太多，只记得一些事件，而忘记了许多珍贵的细节。学东西总是在输入，很少输出，导致自己也不太清楚学懂没。</p><p>这次碰上疫情，打乱了自己许多计划，在找暑期实习的时候，也找到了自己今后想发展的方向，却发现自己的知识储备和能力并不足以让我通过面试。于是便打算等大四开始，没课了，便好好的补救补救，本来博客按计划也是在大四的时候再开始的。但时不待我，准备了许久托福考试取消，期末考试安排到8月低，打乱了我的实习，中美关系迅速恶劣。我在前年初得计划基本被破坏的一干二净，不得已，只能加快自己的步伐，加速！！<br><img src="/assets/photos/visa.png" alt=""></p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>博客主要分享的是一些cs基础课的上课理解和作业，算是数学转大数据开发的记录吧，偶尔穿插一些游记？日记？</p><p>更新频率的话大概一周一次吧，将知识融会贯通并输出并不是件容易的事情，定下个固定更新频率也是对自己的一种监督，希望能坚持下去。</p><h2 id="日后再更"><a href="#日后再更" class="headerlink" title="日后再更"></a>日后再更</h2>]]></content>
    
    <summary type="html">
    
      第一篇博客，介绍一下自己写博客的初衷。
    
    </summary>
    
    
      <category term="first" scheme="sfarl.github.io/categories/first/"/>
    
    
      <category term="初衷" scheme="sfarl.github.io/tags/%E5%88%9D%E8%A1%B7/"/>
    
  </entry>
  
</feed>
